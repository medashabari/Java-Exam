# -*- coding: utf-8 -*-
"""Artificial Intelligence Lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ztOTd08ZnBuGlwiclpdt5YlCs_BLoDNq

##**Artificial Intelligence Laboratory**

###DFS
"""

#DFS


graph_nodes={
    "A":["B","C"],
    "B":["D","E"],
    "C":["F","G"],
    "D":["H","I"],
    "E":[],
    "F":[],
    "G":[],
    "H":[],
    "I":[]
}
#print(graph_nodes)
visited={} #V=visited,NV = not visited,C=Completed
#parent={}
dfs_order=[]

for node in graph_nodes.keys():
    visited[node]="Nv"
    #parent[node]=None
    
#print(visited)
def dfs(s):
    visited[s]="V"
    dfs_order.append(s)
    
    for u in graph_nodes[s]:
        if visited[u]=="Nv":
            #parent[u]=s
            dfs(u)
    visited[s]="C"
    return dfs_order

print(dfs("A"))

"""##BFS"""

from queue import Queue

graph_nodes={
    "A":["B","C"],
    "B":["D","E"],
    "C":["F","G"],
    "D":["H","I"],
    "E":[],
    "F":[],
    "G":[],
    "H":[],
    "I":[]
}
#print(graph_nodes)
queue=Queue()
visited={}
#parent={}
#level={}
bfs_order=[]

for node in graph_nodes.keys():
    visited[node]="nv"
    #parent[node]=None
    #level[node]=-1
def bfs(s):
    visited[s]="v"
    #level[s]=0
    queue.put(s)
    
    while not queue.empty():
        u=queue.get()
        bfs_order.append(u)
        
        for v in graph_nodes[u]:
            if visited[v]=="nv":
                #visited[v]="v"
                #parent[v]=u
                #level[v]=level[u]+1
                queue.put(v)
    return bfs_order
#bfs("A")
print(bfs("A"))

"""##Travelling sales person"""

v=4
answer=[]
def tsp(graph,v,currPos,n,count,cost):
  if(count==n and graph[currPos][0]):
    answer.append(cost+graph[currPos][0])
    return
  for i in range(n):
    if(v[i]==False and graph[currPos][i]):
      v[i]=True
      tsp(graph,v,i,n,count+1,cost+graph[currPos][i])
      v[i]=False
n=4
graph=[[0,4,12,7],[5,0,0,18],[11,0,0,6],[10,2,3,0]]

v=[False for i in range(n)]
v[0]=True
tsp(graph,v,0,n,1,0)
print(min(answer))

"""#TowerOfHanoi"""

def TowerOfHanoi(n,from_rod,to_rod,aux_rod):
  if n==1:
    print(f"Move disk 1 from rod {from_rod} to rod {to_rod}")
    return
  TowerOfHanoi(n-1,from_rod,aux_rod,to_rod)
  print(f"Move disk {n} from rod {from_rod} to rod {to_rod}")
  TowerOfHanoi(n-1,aux_rod,to_rod,from_rod)
n= int(input("Enter no.of disks : "))
TowerOfHanoi(n,'A','C','B')

"""#Hill Climbing"""

import random

def randomSolution(tsp):
  cities =list(range(len(tsp)))
  solution=[]

  for i in range(len(tsp)):
    randomCity=cities[random.randint(0,len(cities)-1)]
    solution.append(randomCity)
    cities.remove(randomCity)
  return solution
def routeLength(tsp,solution):
  routeLength=0
  for i in range(len(solution)):
    routeLength+=tsp[solution[i-1]][solution[i]]
  return routeLength
def getNeighbours(solution):
  neighbours=[]
  for i in range(len(solution)):
    for j in range(i+1,len(solution)):
      neighbour =solution.copy()
      neighbour[i],neighbour[j]=solution[j],solution[i]
      neighbours.append(neighbour)
  return neighbours
def getBestNeighbour(tsp,neighbours):
  bestRouteLength=routeLength(tsp,neighbours[0])
  bestNeighbour=neighbours[0]
  for neighbour in neighbours:
    currentRouteLength =routeLength(tsp,neighbour)
    if  currentRouteLength <  bestRouteLength:
       bestRouteLength = currentRouteLength
       bestNeighbour = neighbour
  return bestNeighbour,bestRouteLength

def hillClimbing(tsp):
  currentSolution = randomSolution(tsp)
  currentRouteLength =routeLength(tsp,currentSolution)
  neighbours = getNeighbours(currentSolution)
  bestNeighbour,bestNeighbourRouteLength= getBestNeighbour(tsp,neighbours)

  while bestNeighbourRouteLength < currentRouteLength:
    currentSolution = bestNeighbour
    currentRouteLength = bestNeighbourRouteLength
    neighbours = getNeighbours(currentSolution)
    bestNeighbour , bestNeighbourRouteLength = getBestNeighbour(tsp,neighbours)
  return currentSolution , currentRouteLength

def main():
  tsp=[[0,400,500,300],
       [400,0,300,500],
       [500,300,0,400],
       [300,500,400,0]]
  print(hillClimbing(tsp))

if __name__ =="__main__":
  main()

"""#Simulated anneling algorithm"""

from numpy import asarray
from numpy import exp
from numpy.random import randn
from numpy.random import rand
from numpy.random import seed
from matplotlib import pyplot

def  objective(x):
  return x[0]**2.0

def simulated_annealing(objective,bounds,n_iterations,step_size,temp):
  best=bounds[:,0]+rand(len(bounds))*(bounds[:,1]-bounds[:,0])
  best_eval=objective(best)
  curr,curr_eval=best,best_eval
  scores=list()
  for i in range(n_iterations):
    candidate=curr+randn(len(bounds))
    candidate_eval=objective(candidate)
    if(candidate_eval<best_eval):
      best,best_eval=candidate,candidate_eval
      scores.append(best_eval)
      print('>%df(%s)=%.5f'%(i,best,best_eval))
    diff=candidate_eval-curr_eval
    t=temp/float(i+1)
    metropolis= exp(-diff/t)
    if diff <0 or rand() < metropolis:
      curr,curr_eval=candidate,candidate_eval
  return [best,best_eval,scores]

seed(1)
bounds=asarray([[-5.0,5.0]])
n_iterations=1000
step_size = 0.1
temp= 10
best,score,scores=simulated_annealing(objective,bounds,n_iterations,step_size,temp)
print('Done!')
print('f(%s) = %f' %(best,score))
pyplot.plot(scores,'.-')
pyplot.xlabel('Improvement Number')
pyplot.ylabel('Evaluation f(x)')
pyplot.show()

"""#8 Puzzle problem

"""

import copy
from heapq import heappush, heappop
n = 3

row = [ 1, 0, -1, 0 ]
col = [ 0, -1, 0, 1 ]

class priorityQueue:
	def __init__(self):
		self.heap = []

	def push(self, k):
		heappush(self.heap, k)

	def pop(self):
		return heappop(self.heap)

	def empty(self):
		if not self.heap:
			return True
		else:
			return False
class node:	
	def __init__(self, parent, mat, empty_tile_pos,cost, level):
	
		self.parent = parent
		self.mat = mat
		self.empty_tile_pos = empty_tile_pos
		self.cost = cost
		self.level = level
	
	def __lt__(self, nxt):
		return self.cost < nxt.cost


def calculateCost(mat, final) -> int:
	
	count = 0
	for i in range(n):
		for j in range(n):
			if ((mat[i][j]) and
				(mat[i][j] != final[i][j])):
				count += 1
				
	return count

def newNode(mat, empty_tile_pos, new_empty_tile_pos,level, parent, final) -> node:
				
	
	new_mat = copy.deepcopy(mat)

	
	x1 = empty_tile_pos[0]
	y1 = empty_tile_pos[1]
	x2 = new_empty_tile_pos[0]
	y2 = new_empty_tile_pos[1]
	new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]

	
	cost = calculateCost(new_mat, final)

	new_node = node(parent, new_mat, new_empty_tile_pos,
					cost, level)
	return new_node


def printMatrix(mat):
	
	for i in range(n):
		for j in range(n):
			print("%d " % (mat[i][j]), end = " ")
			
		print()

def isSafe(x, y):
	
	return x >= 0 and x < n and y >= 0 and y < n

def printPath(root):
	
	if root == None:
		return
	
	printPath(root.parent)
	printMatrix(root.mat)
	print()

def solve(initial, empty_tile_pos, final):
	
	
	pq = priorityQueue()


	cost = calculateCost(initial, final)
	root = node(None, initial,
				empty_tile_pos, cost, 0)

	
	pq.push(root)

	
	while not pq.empty():	
		minimum = pq.pop()
		if minimum.cost == 0:	
			printPath(minimum)
			return
		for i in range(n):
			new_tile_pos = [
				minimum.empty_tile_pos[0] + row[i],
				minimum.empty_tile_pos[1] + col[i], ]
				
			if isSafe(new_tile_pos[0], new_tile_pos[1]):
				
				child = newNode(minimum.mat,
								minimum.empty_tile_pos,
								new_tile_pos,
								minimum.level + 1,
								minimum, final,)

				pq.push(child)

initial = [ [ 1, 2, 3 ],
			    [ 5, 0, 6 ],
			    [ 7, 8, 4 ] ]


final = [ [ 1, 2, 3 ],
		    [ 5, 8, 6 ],
		    [ 0, 7, 4 ] ]


empty_tile_pos = [ 1, 1 ]


solve(initial, empty_tile_pos, final)

"""#counts the number of times a string occurs in another string"""

def countFreq(pat,txt):
  m=len(pat)
  n=len(txt)
  res=0
  for i in range(n-m+1):
    j=0
    while j<m:
      if(txt[i+j]!=pat[j]):
        break
      j+=1
    if j==m:
      res+=1
      j=0
  return res

if __name__ =='__main__':
  txt=input()
  pat=input()
  print(countFreq(pat,txt))

def count(pat,txt):
  return pat.count(txt)
print(count('manman','man'))

"""#Higher order functions"""

def getCount(listOfElems,cond=None):
  if cond:
    count=sum(cond(elem) for elem in listOfElems)
  else:
    count=len(listOfElems)
  return count
listOfElems = list(map(int,(input("Enter elements").split(","))))
lower=int(input("Enter lower boundary: "))
higher=int(input("Enter higher boundary: "))
count=getCount(listOfElems,lambda x:x>lower and x<higher)
print(f'count of nunbers in a list which are greater than {lower} and less than {higher} is {count}')

20listOfElems =[11,22,33,45,66,77,88,99,101]
c=list(filter(lambda x:x>5 and x<20,listOfElems))
print(c.count(True))

def fun(x):
  return x+x
x=[10,20,30]
print(list(map(fun,x)))

"""#A* Algorithm"""

def aStarAlgo(start_node, stop_node): 
        open_set = set(start_node) 
        closed_set = set()
        g = {} 
        parents = {}
 
        
        g[start_node] = 0
        #so start_node is set to its own parent node
        parents[start_node] = start_node
         
         
        while len(open_set) > 0:
            n = None
 
            #node with lowest f() is found
            for v in open_set:
                if n == None or g[v] + heuristic(v) < g[n] + heuristic(n):
                    n = v
             
                     
            if n == stop_node or Graph_nodes[n] == None:
                pass
            else:
                for (m, weight) in get_neighbors(n):
                    #nodes 'm' not in first and last set are added to first
                    #n is set its parent
                    if m not in open_set and m not in closed_set:
                        open_set.add(m)
                        parents[m] = n
                        g[m] = g[n] + weight
                         
     
                    #for each node m,compare its distance from start i.e g(m) to the
                    #from start through n node
                    else:
                        if g[m] > g[n] + weight:
                            #update g(m)
                            g[m] = g[n] + weight
                            #change parent of m to n
                            parents[m] = n
                             
                            #if m in closed set,remove and add to open
                            if m in closed_set:
                                closed_set.remove(m)
                                open_set.add(m)
 
            if n == None:
                print('Path does not exist!')
                return None
 
            # if the current node is the stop_node
            # then we begin reconstructin the path from it to the start_node
            if n == stop_node:
                path = []
 
                while parents[n] != n:
                    path.append(n)
                    n = parents[n]
 
                path.append(start_node)
 
                path.reverse()
 
                print('Path found: {}'.format(path))
                return path
 
 
            # remove n from the open_list, and add it to closed_list
            # because all of his neighbors were inspected
            open_set.remove(n)
            closed_set.add(n)
 
        print('Path does not exist!')
        return None
         
#define fuction to return neighbor and its distance
#from the passed node
def get_neighbors(v):
    if v in Graph_nodes:
        return Graph_nodes[v]
    else:
        return None
#for simplicity we ll consider heuristic distances given
#and this function returns heuristic distance for all nodes
def heuristic(n):
        H_dist = {
            'S': 5,
            'A': 3,
            'B': 4,
            'C': 2,
            'D': 6,
            'G': 0,
             
        }
 
        return H_dist[n]
 
#Describe your graph here  
Graph_nodes = {
    'S': [('A', 1), ('G', 10)],
    'A':[('B',2),('C',1)],
    'B':[('D', 5)],
    'C':[('D',3),("G",4)],
    'D':None,
     
}
aStarAlgo('S', 'G')

"""#virtual assistant

"""

# Python program to demonstrate creation of an assistant using wolf ram API and python
#wolframa emailid = leyawa2272@leezro.com
#password cselab@ai
#app_id = 'K8L48H-4X622QEXUR'
#pip install wolframalpha
#pip install speechRecognition 
#pip install pipwin
#pipwin install pyaudio

import wolframalpha
import speech_recognition as sr
from time import ctime
import time
import os
import re
import random
app_id = 'K8L48H-4X622QEXUR'
client = wolframalpha.Client(app_id)
 
def listen():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("I am listening...")
        audio = r.listen(source)
    data = ""
    try:
        data = r.recognize_google(audio)
        print("You said: " + data)
    except sr.UnknownValueError:
        print("AI Speech Recognition did not understand audio\nSay again Please")
    except sr.RequestError as e:
        print("Request Failed; {0}".format(e))
    return data
def digital_assistant(data):
    listening=True
    if re.search("hai|hello",data):
        print(random.choice(['hello', 'hai', 'hey']))
    elif "what time is it" in data:
        print(ctime())   
    elif "stop listening" in data:
        listening = False
        print('Listening stopped')
        return listening  
    elif data:
        res = client.query(data)
        answer = next(res.results).text
        print(answer)    
    return listening
time.sleep(2)
print("Hi, what can I do for you?")
listening = True
while listening == True:
    data = listen()
    listening = digital_assistant(data)

"""#Chatbot"""

#pip install tk
from tkinter import *
root=Tk()
def send():
    send="You:"+e.get()
    txt.insert(END,"\n"+send)
    if((e.get().lower()== "hello") or (e.get().lower()=='hai') or (e.get().lower()=='hi') or (e.get().lower()=='hey')):
        txt.insert(END,"\n"+"SREC:Hello")
    elif(e.get().lower()=="how are you?"):
        txt.insert(END,"\n"+"SREC:I am a computer dude I am always good.\nHow are you Student?")
    elif((e.get()=="fine")or(e.get()=="nice")or(e.get()=='cool')):
        txt.insert(END,"\n"+"SREC:Thats'good.")
    elif((e.get().lower()=="can you provide your college address") or (e.get().lower()=="college address")):
        txt.insert(END,"\n"+"SREC:NH-18,Nerawada X Roads,Nandyal, Kurnool, Andhra Pradesh 518501")
    elif((e.get().lower()=="tell me about your college information") or (e.get().lower()=="college information")):
        txt.insert(END,'\n'+"SREC: Our College provides you different types of Engineering, M-tech and \nMBA courses.\
            \nEngineering Programs \n1.CSE\n2.CSE-DS\n3.CSE-D\n4.ECE\n5.MECH\n6.EEE \nM-tech programs\n7.VLSI System design.\nMBA Programs\n8.Master of Bussiness Administration.")
    elif((e.get().lower()=="cse") or (e.get()=="1")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 120 seats in CSE branch")
    elif((e.get().lower()=="cse-ds") or (e.get()=="2")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in CSE-DS branch")
    elif((e.get().lower()=="cse-d") or (e.get()=="3")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in CSE-D branch")
    elif((e.get().lower()=="ece") or (e.get()=="4")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 120 seats in ECE branch")
    elif((e.get().lower()=="mech") or (e.get()=="5")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in MECH branch")
    elif((e.get().lower()=="eee") or (e.get()=="6")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in EEE branch")
    elif((e.get().lower()=="m-tech") or (e.get()=="7")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 18 seats in M-tech program.")
    elif((e.get().lower()=="mba") or (e.get()=="8")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 120 seats in MBA program.")
    elif((e.get().lower()=="tell me about Your college infrastucture") or (e.get().lower()=='college infrastructure')):
        txt.insert(END,'\n'+"SREC: 1.Lecture Halls 2.Central Facilities \n3.Computer centre 4.Laboratories 5.Seminar Halls 6.Tutorial Halls.")
    e.delete(0,END)
    
txt=Text(root)
txt.grid(row=0,column=0,columnspan=2)
e=Entry(root,width=100)
send=Button(root,text="Send",command=send).grid(row=1,column=1)
e.grid(row=1,column=0)
root.title("SREC CHATBOT")
txt.insert(END,"SREC:Welcome to Santhiram Engineering College.\n\n")
txt.insert(END,"----------------------------------------------")
root.mainloop()
