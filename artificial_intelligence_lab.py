# -*- coding: utf-8 -*-
"""Artificial Intelligence Lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ztOTd08ZnBuGlwiclpdt5YlCs_BLoDNq

##**Artificial Intelligence Laboratory**

###DFS
"""

#DFS


graph_nodes={
    "A":["B","C"],
    "B":["D","E"],
    "C":["F","G"],
    "D":["H","I"],
    "E":[],
    "F":[],
    "G":[],
    "H":[],
    "I":[]
}
#print(graph_nodes)
visited={} #V=visited,NV = not visited,C=Completed
#parent={}
dfs_order=[]

for node in graph_nodes.keys():
    visited[node]="Nv"
    #parent[node]=None
    
#print(visited)
def dfs(s):
    visited[s]="V"
    dfs_order.append(s)
    
    for u in graph_nodes[s]:
        if visited[u]=="Nv":
            #parent[u]=s
            dfs(u)
    visited[s]="C"
    return dfs_order

print(dfs("A"))

"""##BFS"""

from queue import Queue

graph_nodes={
    "A":["B","C"],
    "B":["D","E"],
    "C":["F","G"],
    "D":["H","I"],
    "E":[],
    "F":[],
    "G":[],
    "H":[],
    "I":[]
}
#print(graph_nodes)
queue=Queue()
visited={}
#parent={}
#level={}
bfs_order=[]

for node in graph_nodes.keys():
    visited[node]="nv"
    #parent[node]=None
    #level[node]=-1
def bfs(s):
    visited[s]="v"
    #level[s]=0
    queue.put(s)
    
    while not queue.empty():
        u=queue.get()
        bfs_order.append(u)
        
        for v in graph_nodes[u]:
            if visited[v]=="nv":
                #visited[v]="v"
                #parent[v]=u
                #level[v]=level[u]+1
                queue.put(v)
    return bfs_order
#bfs("A")
print(bfs("A"))

"""##Travelling sales person"""

v=4
answer=[]
def tsp(graph,v,currPos,n,count,cost):
  if(count==n and graph[currPos][0]):
    answer.append(cost+graph[currPos][0])
    return
  for i in range(n):
    if(v[i]==False and graph[currPos][i]):
      v[i]=True
      tsp(graph,v,i,n,count+1,cost+graph[currPos][i])
      v[i]=False
n=4
graph=[[0,4,12,7],[5,0,0,18],[11,0,0,6],[10,2,3,0]]

v=[False for i in range(n)]
v[0]=True
tsp(graph,v,0,n,1,0)
print(min(answer))

"""#TowerOfHanoi"""

def TowerOfHanoi(n,from_rod,to_rod,aux_rod):
  if n==1:
    print(f"Move disk 1 from rod {from_rod} to rod {to_rod}")
    return
  TowerOfHanoi(n-1,from_rod,aux_rod,to_rod)
  print(f"Move disk {n} from rod {from_rod} to rod {to_rod}")
  TowerOfHanoi(n-1,aux_rod,to_rod,from_rod)
n= int(input("Enter no.of disks : "))
TowerOfHanoi(n,'A','C','B')

"""#Hill Climbing"""

import random

def randomSolution(tsp):
  cities =list(range(len(tsp)))
  solution=[]

  for i in range(len(tsp)):
    randomCity=cities[random.randint(0,len(cities)-1)]
    solution.append(randomCity)
    cities.remove(randomCity)
  return solution
def routeLength(tsp,solution):
  routeLength=0
  for i in range(len(solution)):
    routeLength+=tsp[solution[i-1]][solution[i]]
  return routeLength
def getNeighbours(solution):
  neighbours=[]
  for i in range(len(solution)):
    for j in range(i+1,len(solution)):
      neighbour =solution.copy()
      neighbour[i],neighbour[j]=solution[j],solution[i]
      neighbours.append(neighbour)
  return neighbours
def getBestNeighbour(tsp,neighbours):
  bestRouteLength=routeLength(tsp,neighbours[0])
  bestNeighbour=neighbours[0]
  for neighbour in neighbours:
    currentRouteLength =routeLength(tsp,neighbour)
    if  currentRouteLength <  bestRouteLength:
       bestRouteLength = currentRouteLength
       bestNeighbour = neighbour
  return bestNeighbour,bestRouteLength

def hillClimbing(tsp):
  currentSolution = randomSolution(tsp)
  currentRouteLength =routeLength(tsp,currentSolution)
  neighbours = getNeighbours(currentSolution)
  bestNeighbour,bestNeighbourRouteLength= getBestNeighbour(tsp,neighbours)

  while bestNeighbourRouteLength < currentRouteLength:
    currentSolution = bestNeighbour
    currentRouteLength = bestNeighbourRouteLength
    neighbours = getNeighbours(currentSolution)
    bestNeighbour , bestNeighbourRouteLength = getBestNeighbour(tsp,neighbours)
  return currentSolution , currentRouteLength

def main():
  tsp=[[0,400,500,300],
       [400,0,300,500],
       [500,300,0,400],
       [300,500,400,0]]
  print(hillClimbing(tsp))

if __name__ =="__main__":
  main()

"""#Simulated anneling algorithm"""

from numpy import asarray
from numpy import exp
from numpy.random import randn
from numpy.random import rand
from numpy.random import seed
from matplotlib import pyplot

def  objective(x):
  return x[0]**2.0

def simulated_annealing(objective,bounds,n_iterations,step_size,temp):
  best=bounds[:,0]+rand(len(bounds))*(bounds[:,1]-bounds[:,0])
  best_eval=objective(best)
  curr,curr_eval=best,best_eval
  scores=list()
  for i in range(n_iterations):
    candidate=curr+randn(len(bounds))
    candidate_eval=objective(candidate)
    if(candidate_eval<best_eval):
      best,best_eval=candidate,candidate_eval
      scores.append(best_eval)
      print('>%df(%s)=%.5f'%(i,best,best_eval))
    diff=candidate_eval-curr_eval
    t=temp/float(i+1)
    metropolis= exp(-diff/t)
    if diff <0 or rand() < metropolis:
      curr,curr_eval=candidate,candidate_eval
  return [best,best_eval,scores]

seed(1)
bounds=asarray([[-5.0,5.0]])
n_iterations=1000
step_size = 0.1
temp= 10
best,score,scores=simulated_annealing(objective,bounds,n_iterations,step_size,temp)
print('Done!')
print('f(%s) = %f' %(best,score))
pyplot.plot(scores,'.-')
pyplot.xlabel('Improvement Number')
pyplot.ylabel('Evaluation f(x)')
pyplot.show()

"""#8 Puzzle problem

"""

import copy
from heapq import heappush, heappop
n = 3

row = [ 1, 0, -1, 0 ]
col = [ 0, -1, 0, 1 ]

class priorityQueue:
	def __init__(self):
		self.heap = []

	def push(self, k):
		heappush(self.heap, k)

	def pop(self):
		return heappop(self.heap)

	def empty(self):
		if not self.heap:
			return True
		else:
			return False
class node:	
	def __init__(self, parent, mat, empty_tile_pos,cost, level):
	
		self.parent = parent
		self.mat = mat
		self.empty_tile_pos = empty_tile_pos
		self.cost = cost
		self.level = level
	
	def __lt__(self, nxt):
		return self.cost < nxt.cost


def calculateCost(mat, final) -> int:
	
	count = 0
	for i in range(n):
		for j in range(n):
			if ((mat[i][j]) and
				(mat[i][j] != final[i][j])):
				count += 1
				
	return count

def newNode(mat, empty_tile_pos, new_empty_tile_pos,level, parent, final) -> node:
				
	
	new_mat = copy.deepcopy(mat)

	
	x1 = empty_tile_pos[0]
	y1 = empty_tile_pos[1]
	x2 = new_empty_tile_pos[0]
	y2 = new_empty_tile_pos[1]
	new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]

	
	cost = calculateCost(new_mat, final)

	new_node = node(parent, new_mat, new_empty_tile_pos,
					cost, level)
	return new_node


def printMatrix(mat):
	
	for i in range(n):
		for j in range(n):
			print("%d " % (mat[i][j]), end = " ")
			
		print()

def isSafe(x, y):
	
	return x >= 0 and x < n and y >= 0 and y < n

def printPath(root):
	
	if root == None:
		return
	
	printPath(root.parent)
	printMatrix(root.mat)
	print()

def solve(initial, empty_tile_pos, final):
	
	
	pq = priorityQueue()


	cost = calculateCost(initial, final)
	root = node(None, initial,
				empty_tile_pos, cost, 0)

	
	pq.push(root)

	
	while not pq.empty():	
		minimum = pq.pop()
		if minimum.cost == 0:	
			printPath(minimum)
			return
		for i in range(n):
			new_tile_pos = [
				minimum.empty_tile_pos[0] + row[i],
				minimum.empty_tile_pos[1] + col[i], ]
				
			if isSafe(new_tile_pos[0], new_tile_pos[1]):
				
				child = newNode(minimum.mat,
								minimum.empty_tile_pos,
								new_tile_pos,
								minimum.level + 1,
								minimum, final,)

				pq.push(child)

initial = [ [ 1, 2, 3 ],
			    [ 5, 0, 6 ],
			    [ 7, 8, 4 ] ]


final = [ [ 1, 2, 3 ],
		    [ 5, 8, 6 ],
		    [ 0, 7, 4 ] ]


empty_tile_pos = [ 1, 1 ]


solve(initial, empty_tile_pos, final)

"""#wumpus world problem"""

import itertools
import copy

#### All your code can go here.

#### You can change the main function as you wish. Run this program to see the output. Also see Agent.py code.

total_count=0

kb=[]           #main knowledge base to store the propositional sentences in cnf form 

actions = []    #store the moves taken by the agent 

current_status = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]      #keep track of the safe spots in the map 
allowed_moves = [[0,1],[0,-1],[1,0],[-1,0]]                     
moves = ['Up','Down','Right','Left']
moves_taken = []

def FindAdjacentRooms(cl):
    cLoc = cl
    validMoves = [[0,1],[0,-1],[-1,0],[1,0]]
    adjRooms = []
    for vM in validMoves:
        room = []
        valid = True
        for v, inc in zip(cLoc,vM):
            z = v + inc
            if z<1 or z>4:
                valid = False
                break
            else:
                room.append(z)
        if valid==True:
            adjRooms.append(room)
    return adjRooms

def legal(r,c):
    if(r>=0 and r<4 and c>=0 and c<4):
        return True
    else:
        return False

def bfs(current,target):                    #### used for going from one safe path to another 
    # print(current_status)                 #### using the current_status list which keeps track of all the safe paths
    visited = []
    for i in range(4):                                      #maintaining the visited list 
        visited.append([False,False,False,False])
    q = []
    dir = {(current[0],current[1]):(None,None)}             #used for keeping track of the directions moved
    q.append((current[0],current[1]))
    visited[current[0]][current[1]]=True                    
    while q:
        s = q.pop(0)
        # print(s)
        # time.sleep(1)
        if s[0]==target[0] and s[1]==target[1]:             #checking if target has been reached 
            break
        for i in range(4):
            newr = s[0]+allowed_moves[i][0]
            newc = s[1]+allowed_moves[i][1]
            if legal(newr,newc) and current_status[newr][newc]==1 and visited[newr][newc]==False:   #checking if next move is legal
                visited[newr][newc]=True                    #update the visited list 
                q.append((newr,newc))
                dir[(newr,newc)]=((s[0],s[1]),moves[i])

    target_moves = []
    top = (target[0],target[1])
    while top!=(current[0],current[1]):
        # print(dir[top][1])                                #adding the moves taken to reach the target
        target_moves.append(dir[top][1])
        top = dir[top][0]
    
    target_moves.reverse()                                  #reversing the list to get the correct order 
    return target_moves

def initialize(ag):                                     #initialize the knowledge base with the rules of the game      
    big_s1 = set()  
    big_s2 = set()
    for i in range(4):
        for j in range(4):
            for l, r in (('B', 'P'), ('S', 'W')):
                neighbours = FindAdjacentRooms([i+1,j+1])
                first_element = set()
                for x,y in neighbours:
                    first_element.add((f'{r}{x}{y}',1))     # converting the formula of bidirection here
                first_element.add((f'{l}{i+1}{j+1}',0))     #  p <=> r V q === (~pVrVq)and(pV~r)and(pV~q)
                kb.append(first_element)                    #first expression is (~pVrVq...)
                for x,y in neighbours:                      #
                    kb.append({(f'{r}{x}{y}',0),(f'{l}{i+1}{j+1}',1)})  ## this expression corresponds to (pV~r)and(pV~q) and so on
                if(r=='P'):
                    big_s1.add((f'{r}{i+1}{j+1}',1))    
                else:
                    big_s2.add((f'{r}{i+1}{j+1}',1))

    kb.append(big_s1)                   #there is atleast one Pit Condition 
    kb.append(big_s2)                   #there is atleast one Wumpus condition 

    # new_big1 = []
    # new_big2 = []]
    k=0
    store = dict()
    for i in range(4):
        for j in range(4):
            for i1 in range(4):
                for j1 in range(4):
                    if i1==i and j1 ==j:
                        continue
                    else:
                        temp = set()
                        temp.add((f'W{i+1}{j+1}',0))
                        temp.add((f'W{i1+1}{j1+1}',0))
                        temp1 = ((f'W{i+1}{j+1}',0),(f'W{i1+1}{j1+1}',0))
                        temp2 = ((f'W{i1+1}{j1+1}',0),(f'W{i+1}{j+1}',0))
                        if (temp1 not in store) or (temp2 not in store):
                            store[temp1]=1
                            store[temp2]=1
                            # print(temp1)
                            k+=1
                            kb.append({(f'W{i+1}{j+1}',0),(f'W{i1+1}{j1+1}',0)})        #there are atmost one wumpus
                            kb.append({(f'P{i+1}{j+1}',0),(f'P{i1+1}{j1+1}',0)})        #there are atmost one pit 
    
    # print(k)
    # ag._curLoc=[1,1]
  

def literal_expr(expr):                 #select the first literal 
    for c in expr:
        for d in c:
            return d[0]
 

def dpll(expr):   
    global total_count
    total_count+=1       
    # print("before",len(expr))                   
    ps = pure_symbols(expr)                 #using the pure symbol function get all the pure symbols 
    # print("ps:")
    # print(ps)
    expr_new = []
    to_add = True
    if len(ps)!=0:
        for c in expr:
            for k in c:
                if k in ps:
                    to_add = False          #checking if pure symbol exists in the clause and removing it if it exists 
                    break
            if to_add==True:
                expr_new.append(c)
            to_add = True
    else:
        expr_new = copy.deepcopy(expr)

    # print("after",len(expr_new))
    # print("after removing ps:")
    # print(expr_new)

    polarity,uc = unit_clauses(expr_new)     #getting unit clauses and also checking if they are any polarising unit clauses 
    if polarity==False:                     # for eg p, ~p 
        # print("i was here")
        return False

    if len(uc)!=0:

        # print("uc is :")
        # print(uc)
        # print("inner clauses are:")
        for i in uc:
            # print(i)
            expr_new.remove(i)               #first remove all the unit clauses 

        # print("after removing unit clauses:")
        # print(expr_new)

        to_change = []
        to_add = True
        for k in expr_new:
            for j in k:
                for i in uc:
                    for z in i:
                        if z==j:
                            # print("was i here?")
                            to_add=False
                            break
                if to_add==False:
                    break
            if to_add==True:
                to_change.append(k)             #remove other clauses containing the unit clauses 
            to_add=True

        # print("after removing inner unit clauses:")
        # print(to_change)
        
        for i in uc:
            new_one= None
            for k in i:
                new_one = {(k[0],1-k[1])}
            # print("new one is :")
            # print(new_one)
            to_change = [c.difference(new_one) for c in to_change]      #remove the negation of the unit clauses from the clauses 
            # print("after removing:")
            # print(to_change)

        # print("after removing negation of inner unit clauses:")
        # print(to_change)
        
        expr_new= copy.deepcopy(to_change)
    
    # print("after1",len(expr_new))

    if(len(expr_new)==0):                            # early termination condition : if there are no clauses its true
        # print("here1")
        return True

    if any([len(c)==0 for c in expr_new]):           # if there is a box clause 
        return False

    if(expr_new!=expr):                              #check if pure symbol/unit clause heurestic did anything 
        # print("took this path")
        return dpll(expr_new)
    else:                                           #at this point pure symbol and unit clause have not produced any effect so start
        # print("took the other one")               #assigning values to variables 
        cnf = copy.deepcopy(expr_new)
        l = literal_expr(cnf)
        expr_new_one=[]
        # expr_new_one = [c for c in cnf if (l, 1) not in c]
        for c in cnf:
            if (l,1) not in c:
                expr_new_one.append(c)
        expr_new_one = [c.difference({(l, 0)}) for c in expr_new_one]
        done = dpll(expr_new_one)
        if done==True:
            return done

        expr_new_one = []

        for c in cnf:
            if (l,0) not in c:
                expr_new_one.append(c)
        expr_new_one = [c.difference({(l, 1)}) for c in expr_new_one]
        done = dpll(expr_new_one)
        if done==True:
            return done

        return False                                               #return false if both fail
    return None

def pure_symbols(expr):
    symbols = set()                             #get the list of symbols             
    for c in expr:
        for d in c:
            symbols.add(d[0])

    main_list = dict()                      
    holding_val = dict()
    for i in symbols:
        main_list[i]=True                       #initially mark all symbols as pure symbols 
    
    for a in expr:
        for b in a:
            # print(b[0])
            if main_list[b[0]]==False:
                continue
            if b[0] in holding_val:
                if b[1]!=holding_val[b[0]]:                #check if var already exists in the dict and mark it as false if other 
                    main_list[b[0]]=False                  #form exists 
            else:
                holding_val[b[0]]=b[1]

    to_ret = set()
    for i in main_list:
        if main_list[i]==True:                              #make a set to return 
            to_ret.add((i,holding_val[i]))

    # print(to_ret)
    return to_ret

def unit_clauses(expr):
    to_ret = list()
    to_ret_cons = True
    track_truth = dict()                            #find unit clauses and also check if complimentary unit clauses are present 
    for d in expr:
        if(len(d)==1):
            for t in d:
                to_ret.append({t})
                if t[0] not in track_truth:
                    track_truth[t[0]]=t[1]
                else:
                    if t[1]!=track_truth[t[0]]:
                        to_ret_cons=False
                        break

    return to_ret_cons,to_ret


def simulation(ag):

    stack = [[1,1]]                 #stack which contains places which are safe to visit 
    current_status[0][0]=1          #current_status list which has places which are marked safe 
    visited = dict()                #dict which keeps track of tiles which have already been visited 
    visited[(0,0)]=1

    while(ag.FindCurrentLocation()!=[4,4]):
        my_tile = ag.FindCurrentLocation()
        stack.pop()                                 #pop the current element from visited 
        visited[(my_tile[0],my_tile[1])]=1           #mark the current element as visited 
        # print("current location is: ") 
        # print(ag.FindCurrentLocation())
        breeze,stench = ag.PerceiveCurrentLocation()
       
        if breeze == True:                                              #add the perception around the environment 
            # print("i feel a breeze")
            kb.append({(f'B{my_tile[0]}{my_tile[1]}',1)})
        else:
            # print("i do not feel a breeze")
            kb.append({(f'B{my_tile[0]}{my_tile[1]}',0)})
        
        if stench == True:
            # print("i smell a stench")
            kb.append({(f'S{my_tile[0]}{my_tile[1]}',1)})
        else:
            # print("i do not smell a stench")
            kb.append({(f'S{my_tile[0]}{my_tile[1]}',0)})

        adj_rooms = FindAdjacentRooms([my_tile[0],my_tile[1]])

        for room in adj_rooms:                                          #check on the neighbours using dpll 
            if (room[0],room[1]) in visited:                            # check if the room is already visited 
                continue
            # print("the room being checked is :")
            # print(room)
            wump_alive = {(f'W{room[0]}{room[1]}',1)}                   #check if wumpus is not present by using kb^~alpha is unsat
            kb.append(wump_alive)
            val1 = dpll(kb)
            if val1 == True :
                # print("marked this room as unsafe for now: ")
                kb.remove(wump_alive)
                wump_alive_here = {(f'W{room[0]}{room[1]}',0)}          #check if wumpus is present 
                kb.append(wump_alive_here)
                val11 = dpll(kb)
                if(val11==False):
                    kb.remove(wump_alive_here)
                    kb.append(wump_alive)
                    # print("the wumpus is probably definitely here")
                    current_status[room[0]-1][room[1]-1]=2              #mark the wumpus is present 
                else:
                    kb.remove(wump_alive_here)
                continue
            kb.remove(wump_alive)
            kb.append({(f'W{room[0]}{room[1]}',0)})                 #check the same conditions for the pit as well 
            pit_present = {(f'P{room[0]}{room[1]}',1)}
            kb.append(pit_present)
            val2 = dpll(kb)
            if val2 == True:
                # print("marked this room as unsafe for now: ")
                kb.remove(pit_present)
                pit_present_here = {(f'P{room[0]}{room[1]}',0)}
                kb.append(pit_present_here)
                val21 = dpll(kb)
                if(val21==False):
                    kb.remove(pit_present_here)
                    kb.append(pit_present)
                    # print("the pit is probably definitely here")
                    current_status[room[0]-1][room[1]-1]=2
                else:
                    kb.remove(pit_present_here)
                continue
            kb.remove(pit_present)
            kb.append({(f'P{room[0]}{room[1]}',0)})
            stack.append(room)                                  # adding room to the stack
            current_status[room[0]-1][room[1]-1]=1         #marking the room as safe 
            

        new_location = []

        if len(stack)==0:                                               #backtracking back to the start if stack is empty 
            stack.append([1,1])
            visited.clear()

        new_location = stack[-1] 
        p1 = [my_tile[0]-1,my_tile[1]-1]
        p2 = [new_location[0]-1,new_location[1]-1]
        path = bfs(p1,p2)

        for p in path:                                  #move to the new location 
            ag.TakeAction(p)
            actions.append(p)
            moves_taken.append(ag.FindCurrentLocation())

    print("tiles gone to reach: ",moves_taken)
    print("actions taken to reach: ",actions)
    print("total number of calls to dpll: ",total_count)
    return None

def main():
    ag = Agent()
    initialize(ag)
    simulation(ag)

 
class Agent:
    def __init__(self):
        self._wumpusWorld = [
                 ['','','',''], # Rooms [1,1] to [4,1]
                 ['','W','P',''], # Rooms [1,2] to [4,2] 
                 ['','','',''], # Rooms [1,3] to [4,3]
                 ['','','',''],  # Rooms [1,4] to [4,4]
                ] # This is the wumpus world shown in the assignment question.
                  # A different instance of the wumpus world will be used for evaluation.
        self._curLoc = [1,1]
        self._isAlive = True
        self._hasExited = False

    def _FindIndicesForLocation(self,loc):
        x,y = loc
        i,j = y-1, x-1
        return i,j

    def _CheckForPitWumpus(self):
        ww = self._wumpusWorld
        i,j = self._FindIndicesForLocation(self._curLoc)
        if 'P' in ww[i][j] or 'W' in ww[i][j]:
            print(ww[i][j])
            self._isAlive = False
            print('Agent is DEAD.')
        return self._isAlive

    def TakeAction(self,action): # The function takes an action and returns whether the Agent is alive
                                # after taking the action.
        validActions = ['Up','Down','Left','Right']
        assert action in validActions, 'Invalid Action.'
        if self._isAlive == False:
            print('Action cannot be performed. Agent is DEAD. Location:{0}'.format(self._curLoc))
            return False
        if self._hasExited == True:
            print('Action cannot be performed. Agent has exited the Wumpus world.'.format(self._curLoc))
            return False

        index = validActions.index(action)
        validMoves = [[0,1],[0,-1],[-1,0],[1,0]]
        move = validMoves[index]
        newLoc = []
        for v, inc in zip(self._curLoc,move):
            z = v + inc #increment location index
            z = 4 if z>4 else 1 if z<1 else z #Ensure that index is between 1 and 4
            newLoc.append(z)
        self._curLoc = newLoc
        print('Action Taken: {0}, Current Location {1}'.format(action,self._curLoc))
        if self._curLoc[0]==4 and self._curLoc[1]==4:
            self._hasExited=True
        return self._CheckForPitWumpus()
    
    def _FindAdjacentRooms(self):
        cLoc = self._curLoc
        validMoves = [[0,1],[0,-1],[-1,0],[1,0]]
        adjRooms = []
        for vM in validMoves:
            room = []
            valid = True
            for v, inc in zip(cLoc,vM):
                z = v + inc
                if z<1 or z>4:
                    valid = False
                    break
                else:
                    room.append(z)
            if valid==True:
                adjRooms.append(room)
        return adjRooms
                
        
    def PerceiveCurrentLocation(self): #This function perceives the current location. 
                                        #It tells whether breeze and stench are present in the current location.
        breeze, stench = False, False
        ww = self._wumpusWorld
        if self._isAlive == False:
            print('Agent cannot perceive. Agent is DEAD. Location:{0}'.format(self._curLoc))
            return [None,None]
        if self._hasExited == True:
            print('Agent cannot perceive. Agent has exited the Wumpus World.'.format(self._curLoc))
            return [None,None]

        adjRooms = self._FindAdjacentRooms()
        for room in adjRooms:
            i,j = self._FindIndicesForLocation(room)
            if 'P' in ww[i][j]:
                breeze = True
            if 'W' in ww[i][j]:
                stench = True
        return [breeze,stench]
    
    def FindCurrentLocation(self):
        return self._curLoc

# def main():
#     ag = Agent()
#     print('curLoc',ag.FindCurrentLocation())
#     print('Percept [breeze, stench] :',ag.PerceiveCurrentLocation())
#     ag.TakeAction('Right')
#     print('Percept',ag.PerceiveCurrentLocation())
#     ag.TakeAction('Right')
#     print('Percept',ag.PerceiveCurrentLocation())
#     ag.TakeAction('Right')
#     print('Percept',ag.PerceiveCurrentLocation())
#     ag.TakeAction('Up')
#     print('Percept',ag.PerceiveCurrentLocation())
#     ag.TakeAction('Up')
#     print('Percept',ag.PerceiveCurrentLocation())
#     ag.TakeAction('Up')
#     print('Percept',ag.PerceiveCurrentLocation())

# if __name__=='__main__':
#     main()  

if __name__=='__main__':
    main()

"""#counts the number of times a string occurs in another string"""

def countFreq(pat,txt):
  m=len(pat)
  n=len(txt)
  res=0
  for i in range(n-m+1):
    j=0
    while j<m:
      if(txt[i+j]!=pat[j]):
        break
      j+=1
    if j==m:
      res+=1
      j=0
  return res

if __name__ =='__main__':
  txt=input()
  pat=input()
  print(countFreq(pat,txt))

def count(pat,txt):
  return pat.count(txt)
print(count('manman','man'))

"""#Higher order functions"""

def getCount(listOfElems,cond=None):
  if cond:
    count=sum(cond(elem) for elem in listOfElems)
  else:
    count=len(listOfElems)
  return count
listOfElems = list(map(int,(input("Enter elements").split(","))))
lower=int(input("Enter lower boundary: "))
higher=int(input("Enter higher boundary: "))
count=getCount(listOfElems,lambda x:x>lower and x<higher)
print(f'count of nunbers in a list which are greater than {lower} and less than {higher} is {count}')

20listOfElems =[11,22,33,45,66,77,88,99,101]
c=list(filter(lambda x:x>5 and x<20,listOfElems))
print(c.count(True))

def fun(x):
  return x+x
x=[10,20,30]
print(list(map(fun,x)))

"""#A* Algorithm"""

def aStarAlgo(start_node, stop_node): 
        open_set = set(start_node) 
        closed_set = set()
        g = {} 
        parents = {}
 
        
        g[start_node] = 0
        #so start_node is set to its own parent node
        parents[start_node] = start_node
         
         
        while len(open_set) > 0:
            n = None
 
            #node with lowest f() is found
            for v in open_set:
                if n == None or g[v] + heuristic(v) < g[n] + heuristic(n):
                    n = v
             
                     
            if n == stop_node or Graph_nodes[n] == None:
                pass
            else:
                for (m, weight) in get_neighbors(n):
                    #nodes 'm' not in first and last set are added to first
                    #n is set its parent
                    if m not in open_set and m not in closed_set:
                        open_set.add(m)
                        parents[m] = n
                        g[m] = g[n] + weight
                         
     
                    #for each node m,compare its distance from start i.e g(m) to the
                    #from start through n node
                    else:
                        if g[m] > g[n] + weight:
                            #update g(m)
                            g[m] = g[n] + weight
                            #change parent of m to n
                            parents[m] = n
                             
                            #if m in closed set,remove and add to open
                            if m in closed_set:
                                closed_set.remove(m)
                                open_set.add(m)
 
            if n == None:
                print('Path does not exist!')
                return None
 
            # if the current node is the stop_node
            # then we begin reconstructin the path from it to the start_node
            if n == stop_node:
                path = []
 
                while parents[n] != n:
                    path.append(n)
                    n = parents[n]
 
                path.append(start_node)
 
                path.reverse()
 
                print('Path found: {}'.format(path))
                return path
 
 
            # remove n from the open_list, and add it to closed_list
            # because all of his neighbors were inspected
            open_set.remove(n)
            closed_set.add(n)
 
        print('Path does not exist!')
        return None
         
#define fuction to return neighbor and its distance
#from the passed node
def get_neighbors(v):
    if v in Graph_nodes:
        return Graph_nodes[v]
    else:
        return None
#for simplicity we ll consider heuristic distances given
#and this function returns heuristic distance for all nodes
def heuristic(n):
        H_dist = {
            'S': 5,
            'A': 3,
            'B': 4,
            'C': 2,
            'D': 6,
            'G': 0,
             
        }
 
        return H_dist[n]
 
#Describe your graph here  
Graph_nodes = {
    'S': [('A', 1), ('G', 10)],
    'A':[('B',2),('C',1)],
    'B':[('D', 5)],
    'C':[('D',3),("G",4)],
    'D':None,
     
}
aStarAlgo('S', 'G')

"""#virtual assistant

"""

# Python program to demonstrate creation of an assistant using wolf ram API and python
#wolframa emailid = leyawa2272@leezro.com
#password cselab@ai
#app_id = 'K8L48H-4X622QEXUR'
#pip install wolframalpha
#pip install speechRecognition 
#pip install pipwin
#pipwin install pyaudio

import wolframalpha
import speech_recognition as sr
from time import ctime
import time
import os
import re
import random
app_id = 'K8L48H-4X622QEXUR'
client = wolframalpha.Client(app_id)
 
def listen():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("I am listening...")
        audio = r.listen(source)
    data = ""
    try:
        data = r.recognize_google(audio)
        print("You said: " + data)
    except sr.UnknownValueError:
        print("AI Speech Recognition did not understand audio\nSay again Please")
    except sr.RequestError as e:
        print("Request Failed; {0}".format(e))
    return data
def digital_assistant(data):
    listening=True
    if re.search("hai|hello",data):
        print(random.choice(['hello', 'hai', 'hey']))
    elif "what time is it" in data:
        print(ctime())   
    elif "stop listening" in data:
        listening = False
        print('Listening stopped')
        return listening  
    elif data:
        res = client.query(data)
        answer = next(res.results).text
        print(answer)    
    return listening
time.sleep(2)
print("Hi, what can I do for you?")
listening = True
while listening == True:
    data = listen()
    listening = digital_assistant(data)

"""#Chatbot"""

#pip install tk
from tkinter import *
root=Tk()
def send():
    send="You:"+e.get()
    txt.insert(END,"\n"+send)
    if((e.get().lower()== "hello") or (e.get().lower()=='hai') or (e.get().lower()=='hi') or (e.get().lower()=='hey')):
        txt.insert(END,"\n"+"SREC:Hello")
    elif(e.get().lower()=="how are you?"):
        txt.insert(END,"\n"+"SREC:I am a computer dude I am always good.\nHow are you Student?")
    elif((e.get()=="fine")or(e.get()=="nice")or(e.get()=='cool')):
        txt.insert(END,"\n"+"SREC:Thats'good.")
    elif((e.get().lower()=="can you provide your college address") or (e.get().lower()=="college address")):
        txt.insert(END,"\n"+"SREC:NH-18,Nerawada X Roads,Nandyal, Kurnool, Andhra Pradesh 518501")
    elif((e.get().lower()=="tell me about your college information") or (e.get().lower()=="college information")):
        txt.insert(END,'\n'+"SREC: Our College provides you different types of Engineering, M-tech and \nMBA courses.\
            \nEngineering Programs \n1.CSE\n2.CSE-DS\n3.CSE-D\n4.ECE\n5.MECH\n6.EEE \nM-tech programs\n7.VLSI System design.\nMBA Programs\n8.Master of Bussiness Administration.")
    elif((e.get().lower()=="cse") or (e.get()=="1")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 120 seats in CSE branch")
    elif((e.get().lower()=="cse-ds") or (e.get()=="2")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in CSE-DS branch")
    elif((e.get().lower()=="cse-d") or (e.get()=="3")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in CSE-D branch")
    elif((e.get().lower()=="ece") or (e.get()=="4")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 120 seats in ECE branch")
    elif((e.get().lower()=="mech") or (e.get()=="5")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in MECH branch")
    elif((e.get().lower()=="eee") or (e.get()=="6")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 60 seats in EEE branch")
    elif((e.get().lower()=="m-tech") or (e.get()=="7")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 18 seats in M-tech program.")
    elif((e.get().lower()=="mba") or (e.get()=="8")):
        txt.insert(END,'\n'+"SREC: Santhiram Engineering college offers 120 seats in MBA program.")
    elif((e.get().lower()=="tell me about Your college infrastucture") or (e.get().lower()=='college infrastructure')):
        txt.insert(END,'\n'+"SREC: 1.Lecture Halls 2.Central Facilities \n3.Computer centre 4.Laboratories 5.Seminar Halls 6.Tutorial Halls.")
    e.delete(0,END)
    
txt=Text(root)
txt.grid(row=0,column=0,columnspan=2)
e=Entry(root,width=100)
send=Button(root,text="Send",command=send).grid(row=1,column=1)
e.grid(row=1,column=0)
root.title("SREC CHATBOT")
txt.insert(END,"SREC:Welcome to Santhiram Engineering College.\n\n")
txt.insert(END,"----------------------------------------------")
root.mainloop()